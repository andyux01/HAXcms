import{Buffer as e}from"../../../buffer";import{noChange as t,_$LH as r}from"./lit-html.js";import{PartType as n}from"./directive.js";import{isPrimitive as a,isTemplateResult as o,isSingleExpression as i}from"./directive-helpers.js";const{R:l,D:s,V:d,I:c,F:f}=r,p=(e,t,r={})=>{if(void 0!==t._$litPart$)throw Error("container already contains a live render");let n,a;const o=[],i=document.createTreeWalker(t,NodeFilter.SHOW_COMMENT,null,!1);let l;for(;null!==(l=i.nextNode());){const t=l.data;if(t.startsWith("lit-part")){if(0===o.length&&void 0!==n)throw Error("there must be only one root part per container");a=u(e,l,o,r),null!=n||(n=a)}else if(t.startsWith("lit-node"))h(l,o,r);else if(t.startsWith("/lit-part")){if(1===o.length&&a!==n)throw Error("internal error");a=m(l,a,o)}}console.assert(void 0!==n,"there should be exactly one root part in a render container"),t._$litPart$=n},u=(e,r,n,i)=>{let f,y;if(0===n.length)y=new c(r,null,void 0,i),f=e;else{const e=n[n.length-1];if("template-instance"===e.type)y=new c(r,null,e.instance,i),e.instance.u.push(y),f=e.result.values[e.instancePartIndex++],e.templatePartIndex++;else if("iterable"===e.type){y=new c(r,null,e.part,i);const t=e.iterator.next();if(t.done)throw f=void 0,e.done=!0,Error("Unhandled shorter than expected iterable");f=t.value,e.part._$AH.push(y)}else y=new c(r,null,e.part,i)}if(f=d(y,f),f===t)n.push({part:y,type:"leaf"});else if(a(f))n.push({part:y,type:"leaf"}),y._$AH=f;else if(o(f)){const e="lit-part "+w(f);if(r.data!==e)throw Error("Hydration value mismatch: Unexpected TemplateResult rendered to part");{const e=c.prototype._$AC(f),t=new l(e,y);n.push({type:"template-instance",instance:t,part:y,templatePartIndex:0,instancePartIndex:0,result:f}),y._$AH=t}}else s(f)?(n.push({part:y,type:"iterable",value:f,iterator:f[Symbol.iterator](),done:!1}),y._$AH=[]):(n.push({part:y,type:"leaf"}),y._$AH=null==f?"":f);return y},m=(e,t,r)=>{if(void 0===t)throw Error("unbalanced part marker");t._$AB=e;const n=r.pop();if("iterable"===n.type&&!n.iterator.next().done)throw Error("unexpected longer than expected iterable");if(r.length>0)return r[r.length-1].part},h=(e,t,r)=>{var a;const o=/lit-node (\d+)/.exec(e.data),l=parseInt(o[1]),s=null!==(a=e.previousElementSibling)&&void 0!==a?a:e.parentElement;if(null===s)throw Error("could not find node for attribute parts");s.removeAttribute("defer-hydration");const c=t[t.length-1];if("template-instance"!==c.type)throw Error("internal error");{const e=c.instance;for(;;){const t=e._$AD.parts[c.templatePartIndex];if(void 0===t||t.type!==n.ATTRIBUTE&&t.type!==n.ELEMENT||t.index!==l)break;if(t.type===n.ATTRIBUTE){const a=new t.ctor(s,t.name,t.strings,c.instance,r),o=i(a)?c.result.values[c.instancePartIndex]:c.result.values,l=!(a.type===n.EVENT||a.type===n.PROPERTY);a._$AI(o,a,c.instancePartIndex,l),c.instancePartIndex+=t.strings.length-1,e.u.push(a)}else{const t=new f(s,c.instance,r);d(t,c.result.values[c.instancePartIndex++]),e.u.push(t)}c.templatePartIndex++}}},w=t=>{const r=new Uint32Array(2).fill(5381);for(const e of t.strings)for(let t=0;t<e.length;t++)r[t%2]=33*r[t%2]^e.charCodeAt(t);const n=String.fromCharCode(...new Uint8Array(r.buffer));return e.from(n,"binary").toString("base64")};export{w as digestForTemplateResult,p as hydrate};