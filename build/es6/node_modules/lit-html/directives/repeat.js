import{noChange as e}from"../lit-html.js";import{directive as t,Directive as s,PartType as r}from"../directive.js";import{getCommittedValue as i,setChildPartValue as l,insertPart as o,removePart as n,setCommittedValue as a}from"../directive-helpers.js";
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
<<<<<<< Updated upstream
 */const u=(e,t,s)=>{const r=new Map;for(let i=t;i<=s;i++)r.set(e[i],i);return r},f=t(class extends s{constructor(e){if(super(e),e.type!==r.CHILD)throw Error("repeat() can only be used in text expressions")}dt(e,t,s){let r;void 0===s?s=t:void 0!==t&&(r=t);const i=[],l=[];let o=0;for(const t of e)i[o]=r?r(t,o):o,l[o]=s(t,o),o++;return{values:l,keys:i}}render(e,t,s){return this.dt(e,t,s).values}update(t,[s,r,f]){var h;const c=i(t),{values:d,keys:v}=this.dt(s,r,f);if(!Array.isArray(c))return this.ht=v,d;const p=null!==(h=this.ht)&&void 0!==h?h:this.ht=[],m=[];let y,g,C=0,x=c.length-1,P=0,j=d.length-1;for(;C<=x&&P<=j;)if(null===c[C])C++;else if(null===c[x])x--;else if(p[C]===v[P])m[P]=l(c[C],d[P]),C++,P++;else if(p[x]===v[j])m[j]=l(c[x],d[j]),x--,j--;else if(p[C]===v[j])m[j]=l(c[C],d[j]),o(t,m[j+1],c[C]),C++,j--;else if(p[x]===v[P])m[P]=l(c[x],d[P]),o(t,c[C],c[x]),x--,P++;else if(void 0===y&&(y=u(v,P,j),g=u(p,C,x)),y.has(p[C]))if(y.has(p[x])){const e=g.get(v[P]),s=void 0!==e?c[e]:null;if(null===s){const e=o(t,c[C]);l(e,d[P]),m[P]=e}else m[P]=l(s,d[P]),o(t,c[C],s),c[e]=null;P++}else n(c[x]),x--;else n(c[C]),C++;for(;P<=j;){const e=o(t,m[j+1]);l(e,d[P]),m[P++]=e}for(;C<=x;){const e=c[C++];null!==e&&n(e)}return this.ht=v,a(t,m),e}});export{f as repeat};
=======
 */const u=(e,t,s)=>{const r=new Map;for(let i=t;i<=s;i++)r.set(e[i],i);return r},f=t(class extends s{constructor(e){if(super(e),e.type!==r.CHILD)throw Error("repeat() can only be used in text expressions")}ht(e,t,s){let r;void 0===s?s=t:void 0!==t&&(r=t);const i=[],l=[];let o=0;for(const t of e)i[o]=r?r(t,o):o,l[o]=s(t,o),o++;return{values:l,keys:i}}render(e,t,s){return this.ht(e,t,s).values}update(t,[s,r,f]){const c=i(t),{values:d,keys:h}=this.ht(s,r,f);if(!Array.isArray(c))return this.dt=h,d;const p=this.dt??=[],m=[];let v,y,g=0,C=c.length-1,x=0,P=d.length-1;for(;g<=C&&x<=P;)if(null===c[g])g++;else if(null===c[C])C--;else if(p[g]===h[x])m[x]=l(c[g],d[x]),g++,x++;else if(p[C]===h[P])m[P]=l(c[C],d[P]),C--,P--;else if(p[g]===h[P])m[P]=l(c[g],d[P]),o(t,m[P+1],c[g]),g++,P--;else if(p[C]===h[x])m[x]=l(c[C],d[x]),o(t,c[g],c[C]),C--,x++;else if(void 0===v&&(v=u(h,x,P),y=u(p,g,C)),v.has(p[g]))if(v.has(p[C])){const e=y.get(h[x]),s=void 0!==e?c[e]:null;if(null===s){const e=o(t,c[g]);l(e,d[x]),m[x]=e}else m[x]=l(s,d[x]),o(t,c[g],s),c[e]=null;x++}else n(c[C]),C--;else n(c[g]),g++;for(;x<=P;){const e=o(t,m[P+1]);l(e,d[x]),m[x++]=e}for(;g<=C;){const e=c[g++];null!==e&&n(e)}return this.dt=h,a(t,m),e}});export{f as repeat};
>>>>>>> Stashed changes
