<<<<<<< Updated upstream
import{_$LH as i}from"./lit-html.js";
=======
import{_$LH as t}from"./lit-html.js";
>>>>>>> Stashed changes
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
<<<<<<< Updated upstream
 */const{I:l}=i,t=i=>null===i||"object"!=typeof i&&"function"!=typeof i,o={HTML:1,SVG:2},n=(i,l)=>void 0===l?void 0!==(null==i?void 0:i._$litType$):(null==i?void 0:i._$litType$)===l,d=i=>void 0!==(null==i?void 0:i._$litDirective$),v=i=>null==i?void 0:i._$litDirective$,e=i=>void 0===i.strings,c=()=>document.createComment(""),r=(i,o,$)=>{var _;const A=i._$AA.parentNode,f=void 0===o?i._$AB:o._$AA;if(void 0===$){const o=A.insertBefore(c(),f),_=A.insertBefore(c(),f);$=new l(o,_,i,i.options)}else{const l=$._$AB.nextSibling,o=$._$AM,g=o!==i;if(g){let l;null===(_=$._$AQ)||void 0===_||_.call($,i),$._$AM=i,void 0!==$._$AP&&(l=i._$AU)!==o._$AU&&$._$AP(l)}if(l!==f||g){let i=$._$AA;for(;i!==l;){const l=i.nextSibling;A.insertBefore(i,f),i=l}}}return $},u=(i,l,o=i)=>(i._$AI(l,o),i),$={},s=(i,l=$)=>i._$AH=l,m=i=>i._$AH,p=i=>{var l;null===(l=i._$AP)||void 0===l||l.call(i,!1,!0);let o=i._$AA;const $=i._$AB.nextSibling;for(;o!==$;){const i=o.nextSibling;o.remove(),o=i}},a=i=>{i._$AR()};export{o as TemplateResultType,a as clearPart,m as getCommittedValue,v as getDirectiveClass,r as insertPart,d as isDirectiveResult,t as isPrimitive,e as isSingleExpression,n as isTemplateResult,p as removePart,u as setChildPartValue,s as setCommittedValue};
=======
 */const{D:o}=t,i=t=>null===t||"object"!=typeof t&&"function"!=typeof t,n={HTML:1,SVG:2},e=(t,o)=>void 0===o?void 0!==t?._$litType$:t?._$litType$===o,l=t=>null!=t?._$litType$?.h,c=t=>void 0!==t?._$litDirective$,d=t=>t?._$litDirective$,f=t=>void 0===t.strings,s=()=>document.createComment(""),r=(t,n,$)=>{const a=t._$AA.parentNode,_=void 0===n?t._$AB:n._$AA;if(void 0===$){const n=a.insertBefore(s(),_),A=a.insertBefore(s(),_);$=new o(n,A,t,t.options)}else{const o=$._$AB.nextSibling,n=$._$AM,A=n!==t;if(A){let o;$._$AQ?.(t),$._$AM=t,void 0!==$._$AP&&(o=t._$AU)!==n._$AU&&$._$AP(o)}if(o!==_||A){let t=$._$AA;for(;t!==o;){const o=t.nextSibling;a.insertBefore(t,_),t=o}}}return $},v=(t,o,n=t)=>(t._$AI(o,n),t),$={},m=(t,o=$)=>t._$AH=o,p=t=>t._$AH,h=t=>{t._$AP?.(!1,!0);let o=t._$AA;const n=t._$AB.nextSibling;for(;o!==n;){const t=o.nextSibling;o.remove(),o=t}},j=t=>{t._$AR()};export{n as TemplateResultType,j as clearPart,p as getCommittedValue,d as getDirectiveClass,r as insertPart,l as isCompiledTemplateResult,c as isDirectiveResult,i as isPrimitive,f as isSingleExpression,e as isTemplateResult,h as removePart,v as setChildPartValue,m as setCommittedValue};
>>>>>>> Stashed changes
