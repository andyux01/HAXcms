<<<<<<< Updated upstream
import{nothing as t}from"../../lit/html.js";import{directive as i,PartType as o}from"../../lit/directive.js";import{AsyncDirective as s}from"../../lit/async-directive.js";const n=["top","right","bottom","left"];class e extends s{constructor(t){if(super(t),t.type!==o.ELEMENT)throw Error("The `position` directive must be used in attribute position.")}render(i,o){return t}update(t,[i,o]){var s;return void 0===this.l&&(this.l=null===(s=t.options)||void 0===s?void 0:s.host,this.l.addController(this)),this.j=t.element,this.S=i,this.C=null!=o?o:["left","top","width","height"],this.render(i,o)}hostUpdated(){this.F()}F(){var t,i;const o="function"==typeof this.S?this.S():null===(t=this.S)||void 0===t?void 0:t.value,s=o.offsetParent;if(void 0===o||!s)return;const r=o.getBoundingClientRect(),l=s.getBoundingClientRect();null===(i=this.C)||void 0===i||i.forEach((t=>{const i=n.includes(t)?r[t]-l[t]:r[t];this.j.style[t]=i+"px"}))}}const r=i(e);export{e as Position,r as position};
=======
import{nothing as t}from"../../lit/html.js";import{directive as i,PartType as s}from"../../lit/directive.js";import{AsyncDirective as o}from"../../lit/async-directive.js";const r=["top","right","bottom","left"];class e extends o{constructor(t){if(super(t),t.type!==s.ELEMENT)throw Error("The `position` directive must be used in attribute position.")}render(i,s){return t}update(t,[i,s]){return void 0===this.l&&(this.l=t.options?.host,this.l.addController(this)),this.N=t.element,this.P=i,this.S=s??["left","top","width","height"],this.render(i,s)}hostUpdated(){this.C()}C(){const t="function"==typeof this.P?this.P():this.P?.value,i=t.offsetParent;if(void 0===t||!i)return;const s=t.getBoundingClientRect(),o=i.getBoundingClientRect();this.S?.forEach((t=>{const i=r.includes(t)?s[t]-o[t]:s[t];this.N.style[t]=i+"px"}))}}const n=i(e);export{e as Position,n as position};
>>>>>>> Stashed changes
