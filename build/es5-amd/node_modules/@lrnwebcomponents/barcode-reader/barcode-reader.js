define(["exports", "meta", "../../lit-element/lit-element.js", "../es-global-bridge/es-global-bridge.js"], function (_exports, meta, _litElement, _esGlobalBridge) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.BarcodeReader = void 0;
  meta = babelHelpers.interopRequireWildcard(meta);

  function _templateObject2_c28692f0994311ebb1a5332c5e6bdde2() {
    var data = babelHelpers.taggedTemplateLiteral(["\n      :host {\n        display: block;\n        position: relative;\n      }\n      canvas {\n        display:none;\n      }\n      video {\n        width: 100%;\n        height: 100%;\n      }\n      #overlay {\n        position: absolute;\n        top: 0;\n        left: 0;\n        bottom: 0;\n        right: 0;\n        background-color: transparent;\n        border-style: solid;\n        border-color: rgba(0, 0, 0, 0.5);\n        pointer-events: none;\n        z-index: 20;\n        border-width: 2em;\n      }\n      #scanline {\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n        visibility: hidden;\n        background: linear-gradient(to bottom, transparent 51%, red 51%, transparent 52%)\n      }\n    "]);

    _templateObject2_c28692f0994311ebb1a5332c5e6bdde2 = function _templateObject2_c28692f0994311ebb1a5332c5e6bdde2() {
      return data;
    };

    return data;
  }

  function _templateObject_c28692f0994311ebb1a5332c5e6bdde2() {
    var data = babelHelpers.taggedTemplateLiteral(["\n      <!--<div>\n        <div id=\"overlay\">\n          <div id=\"scanline\"></div>\n        </div>\n        <canvas id=\"canvas\" width=\"640\" height=\"480\"></canvas>\n        <video id=\"video\" width=\"640\" height=\"480\" muted autoplay playsinline/>\n      </div>\n      <pre><code id=\"result\"></code></pre>\n      <div>\n        <a class=\"button\" id=\"startButton\">Start</a>\n        <a class=\"button\" id=\"resetButton\">Reset</a>\n        <p id=\"result\">Result:</p>\n      </div>-->\n        <br><br><br><br><br><br>\n      <h1>Pure JS Barcode Reader</h1>\n      <div>Barcode result: <span id=\"dbr\"></span></div>\n      <div class=\"select\">\n        <label for=\"videoSource\">Video source: </label><select id=\"videoSource\"></select>\n      </div>\n      <button id=\"go\">Read Barcode</button>\n      <div>\n        <video muted autoplay id=\"video\" playsinline=\"true\"></video>\n        <canvas id=\"canvas\" width=\"640\" height=\"480\" style=\"display: none; float: bottom;\"></canvas>\n      </div>\n    "]);

    _templateObject_c28692f0994311ebb1a5332c5e6bdde2 = function _templateObject_c28692f0994311ebb1a5332c5e6bdde2() {
      return data;
    };

    return data;
  }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  //import { BrowserQRCodeReader } from '@zxing/browser';

  /**
   * `barcode-reader`
   * `Reads barcodes`
   * @demo demo/index.html
   * @element barcode-reader
   * Amalgamation of https://github.com/justinribeiro/barcode-reader/blob/master/barcode-reader.js for LitElement & render
   * & https://github.com/zxing-js for img processing.
   */
  var BarcodeReader = /*#__PURE__*/function (_LitElement) {
    babelHelpers.inherits(BarcodeReader, _LitElement);

    var _super = _createSuper(BarcodeReader);

    babelHelpers.createClass(BarcodeReader, [{
      key: "render",

      /**
       * LitElement render callback
       */
      value: function render() {
        return (0, _litElement.html)(_templateObject_c28692f0994311ebb1a5332c5e6bdde2());
      }
    }], [{
      key: "styles",

      /**
       * LitElement style callback
       */
      get: function get() {
        return (0, _litElement.css)(_templateObject2_c28692f0994311ebb1a5332c5e6bdde2());
      }
    }]);

    function BarcodeReader() {
      var _this;

      babelHelpers.classCallCheck(this, BarcodeReader);
      _this = _super.call(this);
      window.ESGlobalBridge.requestAvailability();
      window.ESGlobalBridge.instance.load("ZXing", decodeURIComponent(meta.url) + "/../lib/zxing.js");
      window.addEventListener("es-bridge-zxing-loaded", _this._control.bind(babelHelpers.assertThisInitialized(_this)));
      return _this;
    }
    /**_zxingLoaded(e) {
      if (window.ZXing) {
        this.ZXing = ZXing();
        let decodePtr = ZXing.Runtime.addFunction(decodeCallback);
      } else {
        setTimeout(tick, 10);
      }
    }*/


    babelHelpers.createClass(BarcodeReader, [{
      key: "_control",
      value: function _control() {
        var videoElement = this.shadowRoot.querySelector('#video');
        var canvas = this.shadowRoot.querySelector('#canvas');
        var ctx = canvas.getContext('2d');
        var videoSelect = this.shadowRoot.querySelector('select#videoSource');
        var videoOption = this.shadowRoot.getElementById('videoOption');
        var buttonGo = this.shadowRoot.getElementById('go');
        var barcode_result = this.shadowRoot.getElementById('dbr');
        var isPaused = false;
        var videoWidth = 640,
            videoHeight = 480;
        var mobileVideoWidth = 240,
            mobileVideoHeight = 320;
        var isPC = true;
        var ZXing = null;
        var decodePtr = null;

        var tick = function tick() {
          console.log("tick");

          if (window.ZXing) {
            ZXing = ZXing();
            decodePtr = ZXing.Runtime.addFunction(decodeCallback);
          } else {
            setTimeout(tick, 10);
          }
        };

        tick();

        var decodeCallback = function decodeCallback(ptr, len, resultIndex, resultCount) {
          console.log("decodeCallback");
          var result = new Uint8Array(ZXing.HEAPU8.buffer, ptr, len);
          console.log(String.fromCharCode.apply(null, result));
          barcode_result.textContent = String.fromCharCode.apply(null, result);
          buttonGo.disabled = false;

          if (isPC) {
            canvas.style.display = 'block';
          } else {
            mobileCanvas.style.display = 'block';
          }
        }; // check devices


        function browserRedirect() {
          console.log("browserRedirect");
          var deviceType;
          var sUserAgent = navigator.userAgent.toLowerCase();
          var bIsIpad = sUserAgent.match(/ipad/i) == "ipad";
          var bIsIphoneOs = sUserAgent.match(/iphone os/i) == "iphone os";
          var bIsMidp = sUserAgent.match(/midp/i) == "midp";
          var bIsUc7 = sUserAgent.match(/rv:1.2.3.4/i) == "rv:1.2.3.4";
          var bIsUc = sUserAgent.match(/ucweb/i) == "ucweb";
          var bIsAndroid = sUserAgent.match(/android/i) == "android";
          var bIsCE = sUserAgent.match(/windows ce/i) == "windows ce";
          var bIsWM = sUserAgent.match(/windows mobile/i) == "windows mobile";

          if (bIsIpad || bIsIphoneOs || bIsMidp || bIsUc7 || bIsUc || bIsAndroid || bIsCE || bIsWM) {
            deviceType = 'phone';
          } else {
            deviceType = 'pc';
          }

          return deviceType;
        }

        if (browserRedirect() == 'pc') {
          isPC = true;
        } else {
          isPC = false;
        } // stackoverflow: http://stackoverflow.com/questions/4998908/convert-data-uri-to-file-then-append-to-formdata/5100158


        function dataURItoBlob(dataURI) {
          console.log("dataURItoBlob"); // convert base64/URLEncoded data component to raw binary data held in a string

          var byteString;
          if (dataURI.split(',')[0].indexOf('base64') >= 0) byteString = atob(dataURI.split(',')[1]);else byteString = unescape(dataURI.split(',')[1]); // separate out the mime component

          var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0]; // write the bytes of the string to a typed array

          var ia = new Uint8Array(byteString.length);

          for (var i = 0; i < byteString.length; i++) {
            ia[i] = byteString.charCodeAt(i);
          }

          return new Blob([ia], {
            type: mimeString
          });
        } // add button event


        buttonGo.onclick = function () {
          console.log("Click");

          if (isPC) {
            canvas.style.display = 'none';
          } else {
            mobileCanvas.style.display = 'none';
          }

          isPaused = false;
          scanBarcode();
          buttonGo.disabled = true;
        }; // scan barcode


        function scanBarcode() {
          console.log("scanBarcode");
          barcode_result.textContent = "";

          if (ZXing == null) {
            buttonGo.disabled = false;
            alert("Barcode Reader is not ready!");
            return;
          }

          var data = null,
              context = null,
              width = 0,
              height = 0,
              dbrCanvas = null;

          if (isPC) {
            context = ctx;
            width = videoWidth;
            height = videoHeight;
            dbrCanvas = canvas;
          } else {
            context = mobileCtx;
            width = mobileVideoWidth;
            height = mobileVideoHeight;
            dbrCanvas = mobileCanvas;
          }

          context.drawImage(videoElement, 0, 0, width, height);
          var vid = this.shadowRoot.getElementById("video");
          console.log("video width: " + vid.videoWidth + ", height: " + vid.videoHeight);
          var barcodeCanvas = document.createElement("canvas");
          barcodeCanvas.width = vid.videoWidth;
          barcodeCanvas.height = vid.videoHeight;
          var barcodeContext = barcodeCanvas.getContext('2d');
          var imageWidth = vid.videoWidth,
              imageHeight = vid.videoHeight;
          barcodeContext.drawImage(videoElement, 0, 0, imageWidth, imageHeight); // read barcode

          var imageData = barcodeContext.getImageData(0, 0, imageWidth, imageHeight);
          var idd = imageData.data;

          var image = ZXing._resize(imageWidth, imageHeight);

          console.time("decode barcode");

          for (var i = 0, j = 0; i < idd.length; i += 4, j++) {
            ZXing.HEAPU8[image + j] = idd[i];
          }

          var err = ZXing._decode_any(decodePtr);

          console.timeEnd('decode barcode');
          console.log("error code", err);

          if (err == -2) {
            setTimeout(scanBarcode, 30);
          }
        } // https://github.com/samdutton/simpl/tree/gh-pages/getusermedia/sources


        var videoSelect = this.shadowRoot.querySelector('select#videoSource');
        navigator.mediaDevices.enumerateDevices().then(gotDevices).then(getStream).catch(handleError);
        videoSelect.onchange = getStream;

        function gotDevices(deviceInfos) {
          console.log("gotDevices");

          for (var i = deviceInfos.length - 1; i >= 0; --i) {
            var deviceInfo = deviceInfos[i];
            var option = document.createElement('option');
            option.value = deviceInfo.deviceId;

            if (deviceInfo.kind === 'videoinput') {
              option.text = deviceInfo.label || 'camera ' + (videoSelect.length + 1);
              videoSelect.appendChild(option);
            } else {
              455;
              console.log('Found one other kind of source/device: ', deviceInfo);
            }
          }
        }

        function getStream() {
          console.log("getStream");
          buttonGo.disabled = false;

          if (window.stream) {
            window.stream.getTracks().forEach(function (track) {
              track.stop();
            });
          }

          var constraints = {
            video: {
              deviceId: {
                exact: videoSelect.value
              }
            }
          };
          navigator.mediaDevices.getUserMedia(constraints).then(gotStream).catch(handleError);
        }

        function gotStream(stream) {
          console.log("gotStream");
          window.stream = stream; // make stream available to console

          videoElement.srcObject = stream;
        }

        function handleError(error) {
          console.log("handleError");
          console.log('Error: ', error);
        }
      }
      /**
       * Convention we use
       */

    }, {
      key: "firstUpdated",

      /**
       * LitElement ready
       */
      value: function firstUpdated() {
        this.start().then(function (r) {
          return console.log('Hit');
        });
        this.__context = this.shadowRoot.querySelector('canvas').getContext('2d');
        this.__video = this.shadowRoot.querySelector('video');
        this.__videoInputSelector = this.shadowRoot.querySelector('#videoInput');
      }
    }, {
      key: "_onFrame",
      value: function () {
        var _onFrame2 = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
          var sleep;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  sleep = function sleep(delay) {
                    return new Promise(function (resolve) {
                      return setTimeout(resolve, delay);
                    });
                  };

                  _context.next = 3;
                  return sleep(5000);

                case 3:
                  //Best delay function I could find
                  if (this.__video.videoWidth > 0) {
                    this._drawFrame(this.__video);
                  }

                  this.__animationFrameId = requestAnimationFrame(this._onFrame.bind(this));

                case 5:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function _onFrame() {
          return _onFrame2.apply(this, arguments);
        }

        return _onFrame;
      }()
    }, {
      key: "_drawFrame",
      value: function _drawFrame(frameData) {
        this.__context.drawImage(frameData, 0, 0, 640, 480, 0, 0, 640, 480);

        this._processFrame().then(function (r) {
          return console.log("Hit draw frame promise#1");
        });
      }
    }, {
      key: "_processFrame",
      value: function () {
        var _processFrame2 = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
          var sourceElem;
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  console.log("Hit Process Frame");
                  sourceElem = this.shadowRoot.querySelector('#video'); //const devices = await navigator.mediaDevices.enumerateDevices();
                  //console.log(devices);
                  //console.log(devices[3].toString());
                  //console.log(devices[3].toString().includes("video"));
                  //const videoDevices = devices.filter(device => device.kind === 'videoinput');
                  //console.log(videoDevices[0]);
                  //console.log(videoDevices[0].deviceId);
                  //console.log(videoDevices[3].toString());
                  // choose your media device (webcam, frontal camera, back camera, etc.)
                  //const selectedDeviceId = videoDevices[0].deviceId;
                  //console.log("ID:"+selectedDeviceId);

                  console.log("After hit");

                case 3:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function _processFrame() {
          return _processFrame2.apply(this, arguments);
        }

        return _processFrame;
      }()
    }, {
      key: "start",
      value: function () {
        var _start = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
          var _this2 = this;

          var constraints, stream;
          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  this._control(); // bigger video = more memory = more OOM on constrained devices


                  constraints = {
                    'audio': false,
                    'video': {
                      width: {
                        min: 640,
                        ideal: 640,
                        max: 1280
                      },
                      height: {
                        min: 480,
                        ideal: 480,
                        max: 720
                      }
                    }
                  };
                  _context3.next = 4;
                  return navigator.mediaDevices.getUserMedia(constraints);

                case 4:
                  stream = _context3.sent;

                  this.__video.addEventListener('loadeddata', function (e) {
                    _this2.__animationFrameId = requestAnimationFrame(_this2._onFrame.bind(_this2));
                  });

                  this.__video.srcObject = stream;
                  this.__stream = stream;

                case 8:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function start() {
          return _start.apply(this, arguments);
        }

        return start;
      }()
    }, {
      key: "stop",
      value: function stop() {
        this.__stream.getTracks()[0].stop();
      }
    }], [{
      key: "tag",
      get: function get() {
        return "barcode-reader";
      }
    }]);
    return BarcodeReader;
  }(_litElement.LitElement);

  _exports.BarcodeReader = BarcodeReader;
  customElements.define(BarcodeReader.tag, BarcodeReader);
});