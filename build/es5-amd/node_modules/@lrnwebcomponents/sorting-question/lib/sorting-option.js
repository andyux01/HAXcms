define(["exports", "../../../lit/index.js", "../../simple-icon/lib/simple-icons.js", "../../simple-icon/lib/simple-icon-lite.js"], function (_exports, _index, _simpleIcons, _simpleIconLite) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.SortingOption = void 0;
  var _templateObject_4db54b50e8f211edb01b473406559cea, _templateObject2_4db54b50e8f211edb01b473406559cea;
  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }
  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var SortingOption = /*#__PURE__*/function (_LitElement) {
    babelHelpers.inherits(SortingOption, _LitElement);
    var _super = _createSuper(SortingOption);
    // HTMLElement life-cycle, built in; use this for setting defaults
    function SortingOption() {
      var _this;
      babelHelpers.classCallCheck(this, SortingOption);
      _this = _super.call(this);
      _this.option = "option";
      _this.setAttribute("draggable", true);
      _this.addEventListener("mousedown", _this.getCurrentPosition);
      _this.addEventListener("drag", _this.dragStart);
      _this.addEventListener("dragend", _this.dragEnd);
      _this.addEventListener("mouseup", _this.dragEnd);
      return _this;
    }
    babelHelpers.createClass(SortingOption, [{
      key: "getCurrentPosition",
      value: function getCurrentPosition() {
        if (!this.disabled) {
          this.style.backgroundColor = "darkgray";
          this.removeAttribute("correct");
          this.removeAttribute("incorrect");
          var mouseTracker = window.event;
          var posY = mouseTracker.clientY;
          this.currentPosition = posY;
        }
      }
    }, {
      key: "dragStart",
      value: function dragStart() {
        if (!this.disabled) {
          //distance above or below current pos to switch index
          var changeBuffer = 30;
          //if slottted images increase change buffer size
          if (this.querySelectorAll("img").length > 0) {
            changeBuffer = 70;
          }
          // this.style.visibility = "hidden";
          var mouseTracker = window.event;
          var posY = mouseTracker.clientY;
          //drag stop counts as drag for some reason so make sure not to set drag pos to zero
          if (posY != 0 && posY > 0) {
            this.dragPosition = posY;
          }
          var element = this;
          var parent = this.parentNode;
          //going up
          if (this.dragPosition + changeBuffer < this.currentPosition) {
            //find old index
            var oldIndex;
            for (var i = 0; i < parent.children.length; i++) {
              if (parent.children[i].isEqualNode(element)) {
                oldIndex = i;
              }
            }
            //set new index
            if (oldIndex != 0) {
              parent.insertBefore(element, parent.children[oldIndex - 1]);
              this.currentPosition = this.dragPosition;
              return;
            }
          }
          //going down
          if (this.dragPosition - changeBuffer > this.currentPosition) {
            //find old index
            var oldIndex;
            for (var i = 0; i < parent.children.length; i++) {
              if (parent.children[i].isEqualNode(element)) {
                oldIndex = i;
              }
            }
            //set new index
            if (oldIndex != parent.children.length - 1) {
              parent.insertBefore(parent.children[oldIndex + 1], element);
              this.currentPosition = this.dragPosition;
              return;
            }
          }
        }
      }
    }, {
      key: "dragEnd",
      value: function dragEnd() {
        if (!this.disabled) {
          this.style.backgroundColor = "white";
        }
      }

      //To Do: change color of up arrowed otption to see which one moved better
      // then reset the color of all other options
    }, {
      key: "upArrowSort",
      value: function upArrowSort(element) {
        if (!this.disabled) {
          var parent = element.parentNode;
          parent.childNodes.forEach(function (child) {
            if (child.tagName === "SORTING-OPTION") {
              child.style.backgroundColor = "white";
            }
          });
          this.style.backgroundColor = "darkgray";
          //find old index
          var oldIndex;
          for (var i = 0; i < parent.children.length; i++) {
            if (parent.children[i].isEqualNode(element)) {
              oldIndex = i;
            }
          }
          //set new index
          if (oldIndex != 0) {
            parent.insertBefore(element, parent.children[oldIndex - 1]);
            this.shadowRoot.querySelector("#upArrow").focus();
            return;
          }
          //keep focus on up-sort
        }
      }
    }, {
      key: "downArrowSort",
      value: function downArrowSort(element) {
        if (!this.disabled) {
          var parent = element.parentNode;
          parent.childNodes.forEach(function (child) {
            if (child.tagName === "SORTING-OPTION") {
              child.style.backgroundColor = "white";
            }
          });
          this.style.backgroundColor = "darkgray";
          //find old index
          var oldIndex;
          for (var i = 0; i < parent.children.length; i++) {
            if (parent.children[i].isEqualNode(element)) {
              oldIndex = i;
            }
          }
          //set new index
          if (oldIndex != parent.children.length - 1) {
            parent.insertBefore(parent.children[oldIndex + 1], element);
            return;
          }
        }
      }

      // Lit life-cycle; this fires the 1st time the element is rendered on the screen
      // this is a sign it is safe to make calls to this.shadowRoot
    }, {
      key: "firstUpdated",
      value: function firstUpdated(changedProperties) {
        if (babelHelpers.get(babelHelpers.getPrototypeOf(SortingOption.prototype), "firstUpdated", this)) {
          babelHelpers.get(babelHelpers.getPrototypeOf(SortingOption.prototype), "firstUpdated", this).call(this, changedProperties);
        }
        var el = this;
        this.shadowRoot.querySelector("#upArrow").addEventListener("click", function () {
          el.upArrowSort(el);
        });
        //add same event listener for enter key
        this.shadowRoot.querySelector("#upArrow").addEventListener("keypress", function (e) {
          if (e.key === "Enter") {
            el.upArrowSort(el);
          }
        });
        this.shadowRoot.querySelector("#downArrow").addEventListener("click", function () {
          el.downArrowSort(el);
        });
        //add same event listener for enter key
        this.shadowRoot.querySelector("#downArrow").addEventListener("keypress", function (e) {
          if (e.key === "Enter") {
            el.downArrowSort(el);
          }
        });
      }

      // CSS - specific to Lit
    }, {
      key: "render",
      value:
      // HTML - specific to Lit
      function render() {
        return (0, _index.html)(_templateObject_4db54b50e8f211edb01b473406559cea || (_templateObject_4db54b50e8f211edb01b473406559cea = babelHelpers.taggedTemplateLiteral(["\n      <div class=\"feedback-container\">\n        <simple-icon-lite\n          id=\"correct-icon\"\n          icon=\"check\"\n          alt=\"correct answer\"\n        ></simple-icon-lite>\n        <simple-icon-lite\n          id=\"incorrect-icon\"\n          icon=\"clear\"\n          alt=\"incorrect answer\"\n        ></simple-icon-lite>\n      </div>\n      <button tabindex=\"-1\" class=\"option-slot-wrapper\"><slot></slot></button>\n      <div class=\"arrow-container\">\n        <simple-icon-button-lite\n          id=\"upArrow\"\n          icon=\"arrow-upward\"\n          @click=\"", "\"\n          alt=\"up arrow click me to move the option up\"\n        ></simple-icon-button-lite>\n        <simple-icon-button-lite\n          id=\"downArrow\"\n          icon=\"arrow-downward\"\n          @click=\"", "\"\n          alt=\"down arrow click me to move the option down\"\n        ></simple-icon-button-lite>\n      </div>\n    "])), this.upArrowSort, this.downArrowSort);
      }
    }], [{
      key: "tag",
      get:
      // a convention I enjoy so you can change the tag name in 1 place
      function get() {
        return "sorting-option";
      }

      // properties that you wish to use as data in HTML, CSS, and the updated life-cycle
    }, {
      key: "properties",
      get: function get() {
        return {
          disabled: {
            type: Boolean
          }
        };
      }
    }, {
      key: "styles",
      get: function get() {
        return (0, _index.css)(_templateObject2_4db54b50e8f211edb01b473406559cea || (_templateObject2_4db54b50e8f211edb01b473406559cea = babelHelpers.taggedTemplateLiteral(["\n      :host {\n        border: 2px black solid;\n        border-radius: 5px;\n        width: 95%;\n        margin-top: 5px;\n        margin-bottom: 5px;\n        height: 100%;\n        min-height: 25px;\n        display: flex;\n        align-items: center;\n        box-shadow: 1px 1px 1px;\n        cursor: grab;\n        z-index: 1;\n        background-color: var(--option-background-color, white);\n        overflow: hidden;\n      }\n\n      :host([correct]) {\n        transition: background-color 0.7s linear;\n        background-color: var(\n          --option-background-color-correct,\n          #3deb3dcc\n        ) !important;\n      }\n\n      :host([incorrect]) {\n        transition: background-color 0.7s linear;\n        background-color: var(\n          --option-background-color-incorrect,\n          #f94343f7\n        ) !important;\n      }\n\n      .option-slot-wrapper {\n        display: flex;\n        align-items: center;\n        z-index: 2;\n        width: 100%;\n        height: 100%;\n        background-color: transparent;\n        border: none;\n        text-align: inherit;\n        font-weight: bold;\n      }\n      :host button {\n        cursor: grab;\n        font-weight: bold;\n      }\n      :host button:active {\n        cursor: grabbing;\n      }\n\n      ::slotted(*) {\n        max-height: 75px;\n      }\n\n      .arrow-container {\n        display: flex;\n        justify-content: flex-end;\n        padding-right: 5px;\n        position: relative;\n        right: 0px;\n        width: 20%;\n        height: 100%;\n        background-color: transparent;\n        align-items: center;\n      }\n\n      .arrow {\n        height: 15px;\n        width: 15px;\n        border-style: solid;\n        border-width: 1px;\n        border-color: black;\n        cursor: pointer;\n        margin-left: 1px;\n        margin-right: 1px;\n        border-radius: 5px;\n        box-shadow: 0px 0px 1px 0px;\n      }\n\n      .up-arrow {\n        transform: rotate(270deg);\n      }\n\n      .down-arrow {\n        transform: rotate(90deg);\n      }\n\n      .feedback-container {\n        width: fit-content;\n        display: flex;\n        height: 100%;\n        align-items: center;\n        padding-left: 5px;\n        background-color: transparent;\n      }\n\n      #correct-icon {\n        display: none;\n        height: 15px;\n        width: 15px;\n        border-radius: 2px;\n        box-shadow: 0px 1px 1px 0px;\n      }\n\n      #incorrect-icon {\n        display: none;\n        height: 15px;\n        width: 15px;\n        border-radius: 2px;\n        box-shadow: 0px 1px 1px 0px;\n      }\n    "])));
      }
    }]);
    return SortingOption;
  }(_index.LitElement); //define element
  _exports.SortingOption = SortingOption;
  window.customElements.define(SortingOption.tag, SortingOption);
});