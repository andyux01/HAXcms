define(["exports", "meta", "require", "../../lit/index.js", "../i18n-manager/lib/I18NMixin.js", "../simple-icon/lib/simple-icon-button-lite.js", "../simple-icon/lib/simple-icons.js", "./lib/sorting-option.js"], function (_exports, meta, _require, _index, _I18NMixin2, _simpleIconButtonLite, _simpleIcons, _sortingOption) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.SortingQuestion = void 0;
  meta = _interopRequireWildcard(meta);
  _require = _interopRequireWildcard(_require);
  var _templateObject_e75f5090e4f411ed85766367b4d3e9fc, _templateObject2_e75f5090e4f411ed85766367b4d3e9fc;
  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || babelHelpers.typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }
  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var SortingQuestion = /*#__PURE__*/function (_I18NMixin) {
    babelHelpers.inherits(SortingQuestion, _I18NMixin);
    var _super = _createSuper(SortingQuestion);
    // HTMLElement life-cycle, built in; use this for setting defaults
    function SortingQuestion() {
      var _this;
      babelHelpers.classCallCheck(this, SortingQuestion);
      _this = _super.call(this);
      _this.celebrate = false;
      _this.shame = false;
      _this.numberOfOptions = _this.children.length;
      _this.numberCorrrect = 0;
      _this.correctOrder = [];
      _this.mute = false;
      _this.noBackground = false;
      _this.question = "Sort the following in order!";
      _this.t = {
        numCorrectLeft: "You Have",
        numCorrectRight: "Correct.",
        submit: "Submit",
        reset: "Reset"
      };
      _this.registerLocalization({
        context: babelHelpers.assertThisInitialized(_this),
        localesPath: new URL("../locales/", meta.url).href,
        locales: ["he", "ja", "es"]
      });
      //set order to be orginal order then scramble the options
      _this.getCorrectOrder();
      setTimeout(_this.randomizeOptions(), 100);
      return _this;
    }
    babelHelpers.createClass(SortingQuestion, [{
      key: "getCorrectOrder",
      value: function getCorrectOrder() {
        var el = this;
        this.childNodes.forEach(function (child) {
          if (child.tagName == "SORTING-OPTION") {
            el.correctOrder.push(child);
          }
        });
      }
    }, {
      key: "randomizeOptions",
      value: function randomizeOptions() {
        //loop through number of options and randomize their indexes
        var indexValues = [];
        for (var i = 0; i < this.numberOfOptions; i++) {
          indexValues.push(i);
        }
        for (var i = 0; i < this.numberOfOptions; i++) {
          var randomIndex1 = Math.floor(Math.random() * (this.numberOfOptions - 0) + 0);
          if (randomIndex1 === undefined) {
            randomIndex1 = 0;
          }
          var targetChild = this.children[indexValues[randomIndex1]];
          var randomIndex2 = Math.floor(Math.random() * (indexValues.length - 0) + 0);
          if (randomIndex2 === undefined) {
            randomIndex2 = 0;
          }
          this.insertBefore(targetChild, this.children[indexValues[randomIndex2]]);
        }
      }
    }, {
      key: "checkOrder",
      value: function checkOrder() {
        var numCorrect = 0;
        for (var i = 0; i < this.numberOfOptions; i++) {
          if (this.children[i].isEqualNode(this.correctOrder[i])) {
            numCorrect += 1;
            this.children[i].removeAttribute("incorrect");
            this.children[i].setAttribute("correct", true);

            //add correct icon
            this.children[i].shadowRoot.querySelector("#correct-icon").style.display = "flex";
            this.children[i].shadowRoot.querySelector("#incorrect-icon").style.display = "none";
          } else {
            this.children[i].removeAttribute("correct");
            this.children[i].setAttribute("incorrect", true);

            //add incorrect icon
            this.children[i].shadowRoot.querySelector("#incorrect-icon").style.display = "flex";
            this.children[i].shadowRoot.querySelector("#correct-icon").style.display = "none";
          }
        }
        this.numberCorrrect = numCorrect;
        if (this.celebrate) {
          this.celebration(this.numberCorrrect, this.numberOfOptions);
        }
        if (this.shame) {
          this.celebration(this.numberCorrrect, this.numberOfOptions);
        }
      }
    }, {
      key: "celebration",
      value: function celebration(score, maximumScore) {
        var _this2 = this;
        if (score == maximumScore) {
          new Promise(function (res, rej) {
            return _require.default(["../multiple-choice/lib/confetti-container.js"], res, rej);
          }).then(function (module) {
            setTimeout(function () {
              _this2.shadowRoot.querySelector("#confetti").setAttribute("popped", "");
            }, 0);
          });
        }
      }
    }, {
      key: "reset",
      value: function reset() {
        var el = this;
        //reset appearance of all options
        this.childNodes.forEach(function (child) {
          if (child.tagName == "SORTING-OPTION") {
            child.shadowRoot.querySelector("#incorrect-icon").style.display = "none";
            child.shadowRoot.querySelector("#correct-icon").style.display = "none";
            child.removeAttribute("incorrect");
            child.removeAttribute("correct");
          }
        });
        this.numberCorrrect = 0;
        this.randomizeOptions();
      }

      // properties that you wish to use as data in HTML, CSS, and the updated life-cycle
    }, {
      key: "updated",
      value:
      // updated fires every time a property defined above changes
      // this allows you to react to variables changing and use javascript to perform logic
      function updated(changedProperties) {
        var _this3 = this;
        changedProperties.forEach(function (oldValue, propName) {
          if (propName === "need" && _this3[propName] === "joy") {
            _this3.classList.add("joyful");
          }
          if (_this3.disabled) {
            var el = _this3;
            var resetButton = _this3.shadowRoot.querySelector(".reset-button");
            var submitButton = _this3.shadowRoot.querySelector(".submit-button");
            resetButton.setAttribute("disabled", true);
            submitButton.setAttribute("disabled", true);
            _this3.childNodes.forEach(function (child) {
              if (child.tagName == "SORTING-OPTION") {
                child.setAttribute("disabled", true);
                child.setAttribute("draggable", false);
                child.removeAttribute("correct");
                child.removeAttribute("incorrect");
                child.shadowRoot.querySelector("#incorrect-icon").style.display = "none";
                child.shadowRoot.querySelector("#correct-icon").style.display = "none";
                child.style.opacity = "0.5";
              }
            });
          } else {
            var resetButton = _this3.shadowRoot.querySelector(".reset-button");
            var submitButton = _this3.shadowRoot.querySelector(".submit-button");
            resetButton.removeAttribute("disabled");
            submitButton.removeAttribute("disabled");
            _this3.childNodes.forEach(function (child) {
              if (child.tagName == "SORTING-OPTION") {
                child.removeAttribute("disabled");
                child.setAttribute("draggable", true);
                child.style.opacity = "1";
              }
            });
          }
          if (propName == "question") {
            _this3.requestUpdate();
          }
        });
      }

      // Lit life-cycle; this fires the 1st time the element is rendered on the screen
      // this is a sign it is safe to make calls to this.shadowRoot
    }, {
      key: "firstUpdated",
      value: function firstUpdated(changedProperties) {
        if (babelHelpers.get(babelHelpers.getPrototypeOf(SortingQuestion.prototype), "firstUpdated", this)) {
          babelHelpers.get(babelHelpers.getPrototypeOf(SortingQuestion.prototype), "firstUpdated", this).call(this, changedProperties);
          if (this.disabled) {
            var resetButton = this.shadowRoot.querySelector(".reset-button");
            var submitButton = this.shadowRoot.querySelector(".submit-button");
            resetButton.setAttribute("disabled", true);
            submitButton.setAttribute("disabled", true);
            this.childNodes.forEach(function (child) {
              if (child.tagName == "SORTING-OPTION") {
                child.setAttribute("disabled", true);
                child.setAttribute("draggable", false);
                child.style.opacity = "0.5";
              }
            });
          }
        }
      }
      // CSS - specific to Lit
    }, {
      key: "render",
      value:
      //To Do: add reset option this resets the option color, the score, and randomizes the options

      // HTML - specific to Lit
      function render() {
        return (0, _index.html)(_templateObject_e75f5090e4f411ed85766367b4d3e9fc || (_templateObject_e75f5090e4f411ed85766367b4d3e9fc = babelHelpers.taggedTemplateLiteral(["\n      <div class=\"sorting-question-header\">", "</div>\n      <confetti-container id=\"confetti\">\n        <div class=\"options\"><slot></slot></div>\n      </confetti-container>\n      <div class=\"sorting-controls\">\n        <span\n          >", "\n          ", "/", "\n          ", "</span\n        >\n        <div class=\"button-container\">\n          <simple-icon-button-lite\n            @click=\"", "\"\n            class=\"reset-button\"\n            icon=\"refresh\"\n            >", "</simple-icon-button-lite\n          >\n          <button\n            @click=\"", "\"\n            class=\"submit-button\"\n            icon=\"submit\"\n          >\n            ", "\n          </button>\n        </div>\n      </div>\n    "])), this.question, this.t.numCorrectLeft, this.numberCorrrect, this.numberOfOptions, this.t.numCorrectRight, this.reset, this.t.reset, this.checkOrder, this.t.submit);
      }

      // HAX specific callback
      // This teaches HAX how to edit and work with your web component
      /**
       * haxProperties integration via file reference
       */
    }], [{
      key: "tag",
      get:
      // a convention I enjoy so you can change the tag name in 1 place
      function get() {
        return "sorting-question";
      }
    }, {
      key: "properties",
      get: function get() {
        return _objectSpread(_objectSpread({}, babelHelpers.get(babelHelpers.getPrototypeOf(SortingQuestion), "properties", this)), {}, {
          question: {
            type: String,
            reflect: true
          },
          correctOrder: {
            type: Array
          },
          numberOfOptions: {
            type: Number
          },
          numberCorrrect: {
            type: Number
          },
          celebrate: {
            type: Boolean
          },
          shame: {
            type: Boolean
          },
          mute: {
            type: Boolean
          },
          disabled: {
            type: Boolean
          },
          noBackground: {
            type: Boolean,
            attribute: "no-background"
          }
        });
      }
    }, {
      key: "styles",
      get: function get() {
        return (0, _index.css)(_templateObject2_e75f5090e4f411ed85766367b4d3e9fc || (_templateObject2_e75f5090e4f411ed85766367b4d3e9fc = babelHelpers.taggedTemplateLiteral(["\n      :host {\n        background-color: var(--sorting-question-background-color, white);\n\n        background-position: center;\n        border: 2px solid black;\n        padding: 15px 10px;\n        display: flex;\n        flex-direction: column;\n        border-radius: 10px;\n        box-shadow: 2px 1px 2px -1px black;\n        margin-top: 10px;\n        margin-bottom: 10px;\n        font-weight: bold;\n        height: inherit;\n        width: inherit;\n      }\n\n      .sorting-question-header {\n        text-align: center;\n        font-size: 20px;\n        font-family: revert;\n        margin-bottom: 10px;\n      }\n\n      .options {\n        margin-bottom: 10px;\n      }\n\n      .sorting-controls {\n        display: flex;\n        justify-content: space-between;\n        padding-right: 5%;\n        font-size: 20px;\n        font-family: revert;\n      }\n\n      .submit-button {\n        border-radius: 5px;\n        border-width: 2px;\n        cursor: pointer;\n        background-color: inherit;\n        box-shadow: 1px 1px 1px 0px;\n        font-weight: bold;\n      }\n\n      .submit-button:hover {\n        opacity: 0.8;\n      }\n\n      .submit-button:active {\n        cursor: default;\n      }\n\n      .button-container {\n        display: flex;\n        justify-content: center;\n        align-items: center;\n      }\n\n      .reset-button {\n        margin-right: 5px;\n        border-radius: 5px;\n        padding: 0 4px;\n        background-color: inherit;\n        box-shadow: 1px 1px 1px 0px;\n        cursor: pointer;\n      }\n\n      .reset-button:disabled {\n        opacity: 0.5;\n      }\n\n      .reset-button simple-icon-button {\n        height: inherit;\n        width: inherit;\n        padding: 1px;\n      }\n    "])));
      }
    }, {
      key: "haxProperties",
      get: function get() {
        return new URL("./lib/".concat(this.tag, ".haxProperties.json"), meta.url).href;
      }
    }]);
    return SortingQuestion;
  }((0, _I18NMixin2.I18NMixin)(_index.LitElement));
  _exports.SortingQuestion = SortingQuestion;
  window.customElements.define(SortingQuestion.tag, SortingQuestion);
});