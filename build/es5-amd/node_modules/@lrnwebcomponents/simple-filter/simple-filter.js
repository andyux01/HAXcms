define(["exports", "../../lit/index.js"], function (_exports, _index) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.SimpleFilterMixin = _exports.SimpleFilter = void 0;
  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }
  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * `simple-filter`
   * `a super class element to provide filtering capabilities`
  
   * @demo demo/index.html
   * @element simple-filter
   */
  var SimpleFilterMixin = function SimpleFilterMixin(SuperClass) {
    return /*#__PURE__*/function (_SuperClass) {
      babelHelpers.inherits(_class, _SuperClass);
      var _super = _createSuper(_class);
      function _class() {
        var _this;
        babelHelpers.classCallCheck(this, _class);
        _this = _super.call(this);
        _this.caseSensitive = false;
        _this.filtered = [];
        _this.multiMatch = false;
        _this.resetList();
        return _this;
      }
      /**
       * Reset this browser.
       */
      babelHelpers.createClass(_class, [{
        key: "resetList",
        value: function resetList() {
          var list = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
          this.items = babelHelpers.toConsumableArray(list);
          this.where = "title";
          this.value = "";
          this.like = "";
        }
      }, {
        key: "update",
        value: function update(changedProperties) {
          var _this2 = this;
          babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype), "update", this).call(this, changedProperties);
          changedProperties.forEach(function (oldValue, propName) {
            if (["items", "where", "like", "caseSensitive", "multiMatch"].includes(propName) && _this2.shadowRoot) {
              clearTimeout(_this2.__debounce);
              _this2.__debounce = setTimeout(function () {
                _this2.filtered = _this2._computeFiltered(_this2.items, _this2.where, _this2.like, _this2.caseSensitive, _this2.multiMatch);
              }, 250);
            }
            if (propName == "filtered" && _this2.shadowRoot) {
              _this2.dispatchEvent(new CustomEvent("filter", {
                bubbles: true,
                cancelable: true,
                composed: true,
                detail: true
              }));
              _this2.dispatchEvent(new CustomEvent("filtered-changed", {
                bubbles: true,
                cancelable: true,
                composed: true,
                detail: {
                  value: _this2.filtered
                }
              }));
            }
          });
        }

        /**
         * Filters the items using the f function provided. Recommended when f function is provided
         */
      }, {
        key: "filter",
        value: function filter() {
          //This forces filter function to do its job :-)
          this.where = "";
        }
        // helper function to escape special characters when regex is the comparison tool but input is user string
      }, {
        key: "escapeRegExp",
        value: function escapeRegExp(text) {
          return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
        }

        /**
         * This filters the items provided
         *
         * @param {array} items These are the items to be filtered.
         * @param {string} where The filterby string.
         * @param {string} like The filter string.
         * @param {boolean} capital This is a flag to determine whether filter should be case sensitive or not.
         * @return array} Filter results.
         */
      }, {
        key: "_computeFiltered",
        value: function _computeFiltered(items, where, like, caseSensitive, multiMatch) {
          var _this3 = this;
          like = this.escapeRegExp(like);
          var regex = null;
          // most logical for search results but not our default for legacy api reasons
          if (multiMatch) {
            var multiPat = like.split('\\ ');
            var patterns = [];
            // support multiple patterns based on space separated words
            multiPat.forEach(function (pat) {
              pat = pat.replace("\\", "").replace("\\?", "").replace("\\.", "").replace("\\!", "");
              if (pat.length > 0) {
                patterns.push("(\\s".concat(pat, "|^").concat(pat, ")"));
              }
            });
            // rejoin them for a combined or statement regex for start of a word or space after word
            // this way we don't get things like "join" matching on "rejoin party"
            like = patterns.join('|');
          }
          var filtered = [];
          //Filter by `like`
          filtered = items.filter(function (item) {
            // regex is going to run multiple times against the same object
            // but we have multiple regex patterns to apply against multiple
            // textual targets. So, we have to rebuild it EVERY run or we get
            // really inconsistent results
            regex = null;
            if (caseSensitive) {
              regex = new RegExp(like, "g");
            } else {
              regex = new RegExp(like, "ig");
            }
            //This is when a complex object is provided
            if (babelHelpers.typeof(item) == "object") {
              //Decompose where incase it is represented in . notation for complex objects
              var decomposed = _this3._decomposeWhere(where, item);
              //Check if the items specified are defined
              if (typeof decomposed == "undefined" && where != "") {
                //Do what I know best
                console.warn("simple-filter was unable to find a property in '" + where + "'");
              }
              // every call to .test will iterate against the same regex
              // so we can't console log without causing discrepancies in output
              // classic monitoring of a value deforms the experiment
              var result = regex.test(decomposed);
              return result;
            }

            //When a simple object of strings is provided
            if (typeof item == "string") {
              return regex.test(item);
            }
            //When a simple object of numbers is provided
            if (typeof item == "number") {
              return regex.test(item.toString());
            }
          });
          return filtered;
        }

        /**
         * This decomposes `where` property to object attributes using . notation
         */
      }, {
        key: "_decomposeWhere",
        value: function _decomposeWhere(where, item) {
          return where.split(".").reduce(function (a, b) {
            return a && a[b];
          }, item);
        }
      }], [{
        key: "properties",
        get: function get() {
          return _objectSpread(_objectSpread({}, babelHelpers.get(babelHelpers.getPrototypeOf(_class), "properties", this)), {}, {
            /**
             * These are the items to be filtered
             */
            items: {
              type: Array
            },
            /**
             * Filter regular expression string
             */
            like: {
              type: String
            },
            /**
             * The filter-by field of your items array of objects
             */
            where: {
              type: String
            },
            /**
             * Enable case sensitivity when filtering
             */
            caseSensitive: {
              type: Boolean,
              attribute: "case-sensitive",
              reflect: true
            },
            /**
             * Enable multi match when filtering so that space separated words are matched
             * as separate words as opposed to a single phrase
             */
            multiMatch: {
              type: Boolean,
              attribute: "multi-match"
            },
            /**
             * Filtered items
             */
            filtered: {
              type: Array
            }
          });
        }
      }]);
      return _class;
    }(SuperClass);
  };
  _exports.SimpleFilterMixin = SimpleFilterMixin;
  var SimpleFilter = /*#__PURE__*/function (_SimpleFilterMixin) {
    babelHelpers.inherits(SimpleFilter, _SimpleFilterMixin);
    var _super2 = _createSuper(SimpleFilter);
    function SimpleFilter() {
      babelHelpers.classCallCheck(this, SimpleFilter);
      return _super2.call(this);
    }
    babelHelpers.createClass(SimpleFilter, null, [{
      key: "tag",
      get: function get() {
        return "simple-filter";
      }
    }]);
    return SimpleFilter;
  }(SimpleFilterMixin(_index.LitElement));
  _exports.SimpleFilter = SimpleFilter;
});