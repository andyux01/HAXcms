define(["exports", "meta", "require", "../../lit/index.js", "../schema-behaviors/schema-behaviors.js", "../simple-colors/simple-colors.js", "../simple-icon/simple-icon.js", "../simple-icon/lib/simple-icons.js", "../simple-fields/lib/simple-fields-field.js", "../simple-toolbar/lib/simple-toolbar-button.js", "../simple-toast/simple-toast.js"], function (_exports, meta, _require, _index, _schemaBehaviors, _simpleColors, _simpleIcon, _simpleIcons, _simpleFieldsField, _simpleToolbarButton, _simpleToast) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.MultipleChoice = void 0;
  meta = _interopRequireWildcard(meta);
  _require = _interopRequireWildcard(_require);
  var _templateObject_33233b30e8f211edb01b473406559cea, _templateObject2_33233b30e8f211edb01b473406559cea, _templateObject3_33233b30e8f211edb01b473406559cea, _templateObject4_33233b30e8f211edb01b473406559cea, _templateObject5_33233b30e8f211edb01b473406559cea, _templateObject6_33233b30e8f211edb01b473406559cea, _templateObject7_33233b30e8f211edb01b473406559cea;
  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || babelHelpers.typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
  function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && babelHelpers.instanceof(outerFn.prototype, Generator) ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == babelHelpers.typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }
  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * `multiple-choice`
   * `Ask the user a question from a set of possible answers.`
   * @demo demo/index.html
   * @element multiple-choice
   */
  var MultipleChoice = /*#__PURE__*/function (_SchemaBehaviors) {
    babelHelpers.inherits(MultipleChoice, _SchemaBehaviors);
    var _super = _createSuper(MultipleChoice);
    function MultipleChoice() {
      var _this;
      babelHelpers.classCallCheck(this, MultipleChoice);
      _this = _super.call(this);
      _this.shadowRootOptions = _objectSpread(_objectSpread({}, _index.LitElement.shadowRootOptions), {}, {
        delegatesFocus: true
      });
      _this.randomize = false;
      _this.hideButtons = false;
      _this.disabled = false;
      _this.singleOption = false;
      _this.checkLabel = "Check answer";
      _this.resetLabel = "Reset";
      _this.question = "";
      _this.answers = [];
      _this.displayedAnswers = [];
      _this.correctText = "Great job!";
      _this.correctIcon = "icons:thumb-up";
      _this.incorrectText = "Better luck next time!";
      _this.incorrectIcon = "icons:thumb-down";
      _this.quizName = "default";
      return _this;
    }
    babelHelpers.createClass(MultipleChoice, [{
      key: "updated",
      value: function updated(changedProperties) {
        var _this2 = this;
        if (babelHelpers.get(babelHelpers.getPrototypeOf(MultipleChoice.prototype), "updated", this)) {
          babelHelpers.get(babelHelpers.getPrototypeOf(MultipleChoice.prototype), "updated", this).call(this, changedProperties);
        }
        changedProperties.forEach(function (oldValue, propName) {
          var notifiedProps = ["answers", "displayedAnswers"];
          if (notifiedProps.includes(propName)) {
            // notify
            var eventName = "".concat(propName.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, "$1-$2").toLowerCase(), "-changed");
            _this2.dispatchEvent(new CustomEvent(eventName, {
              detail: {
                value: _this2[propName]
              }
            }));
          }
          if (propName == "answers" && _this2.answers && _this2.answers.length > 0) {
            _this2.displayedAnswers = babelHelpers.toConsumableArray(_this2._computeDisplayedAnswers(_this2.answers, _this2.randomize));
          }
        });
      }
    }, {
      key: "render",
      value: function render() {
        var _this3 = this;
        return (0, _index.html)(_templateObject_33233b30e8f211edb01b473406559cea || (_templateObject_33233b30e8f211edb01b473406559cea = babelHelpers.taggedTemplateLiteral(["\n      <confetti-container id=\"confetti\">\n        <meta property=\"oer:assessing\" content=\"", "\" />\n        <h3><span property=\"oer:name\">", "</span></h3>\n        ", "\n        ", "\n      </confetti-container>\n    "])), this.relatedResource, this.question, this.singleOption ? (0, _index.html)(_templateObject2_33233b30e8f211edb01b473406559cea || (_templateObject2_33233b30e8f211edb01b473406559cea = babelHelpers.taggedTemplateLiteral(["\n              <fieldset id=\"answers\">\n                ", "\n              </fieldset>\n            "])), this.displayedAnswers.map(function (answer, index) {
          return (0, _index.html)(_templateObject3_33233b30e8f211edb01b473406559cea || (_templateObject3_33233b30e8f211edb01b473406559cea = babelHelpers.taggedTemplateLiteral(["\n                    <simple-fields-field\n                      ?disabled=\"", "\"\n                      property=\"oer:answer\"\n                      type=\"radio\"\n                      name=\"", "\"\n                      .value=\"", "\"\n                      @click=\"", "\"\n                      @value-changed=\"", "\"\n                      label=\"", "\"\n                    ></simple-fields-field>\n                  "])), _this3.disabled, index, answer.userGuess, _this3.clickSingle, _this3.checkedEvent, answer.label ? answer.label : "");
        })) : (0, _index.html)(_templateObject4_33233b30e8f211edb01b473406559cea || (_templateObject4_33233b30e8f211edb01b473406559cea = babelHelpers.taggedTemplateLiteral(["\n              <ul>\n                ", "\n              </ul>\n            "])), this.displayedAnswers.map(function (answer, index) {
          return (0, _index.html)(_templateObject5_33233b30e8f211edb01b473406559cea || (_templateObject5_33233b30e8f211edb01b473406559cea = babelHelpers.taggedTemplateLiteral(["\n                    <li>\n                      <simple-fields-field\n                        ?disabled=\"", "\"\n                        property=\"oer:answer\"\n                        name=\"", "\"\n                        type=\"checkbox\"\n                        label=\"", "\"\n                        .value=\"", "\"\n                        @value-changed=\"", "\"\n                      ></simple-fields-field>\n                    </li>\n                  "])), _this3.disabled, index, answer.label ? answer.label : "", answer.userGuess, _this3.checkedEvent);
        })), !this.hideButtons ? (0, _index.html)(_templateObject6_33233b30e8f211edb01b473406559cea || (_templateObject6_33233b30e8f211edb01b473406559cea = babelHelpers.taggedTemplateLiteral(["\n              <div id=\"buttons\">\n                <simple-toolbar-button\n                  id=\"check\"\n                  ?disabled=\"", "\"\n                  @click=\"", "\"\n                  label=\"", "\"\n                >\n                </simple-toolbar-button>\n                <simple-toolbar-button\n                  id=\"reset\"\n                  ?disabled=\"", "\"\n                  @click=\"", "\"\n                  label=\"", "\"\n                >\n                </simple-toolbar-button>\n              </div>\n            "])), this.disabled, this._verifyAnswers, this.checkLabel, this.disabled, this.resetAnswers, this.resetLabel) : "");
      }
    }, {
      key: "clickSingle",
      value: function clickSingle(e) {
        var _this4 = this;
        if (this.singleOption) {
          this.displayedAnswers.forEach(function (el, i) {
            _this4.displayedAnswers[i].userGuess = false;
          });
        }
      }
    }, {
      key: "checkedEvent",
      value: function checkedEvent(e) {
        var attr = this.displayedAnswers;
        attr[e.target.name].userGuess = e.detail.value;
        this.displayedAnswers = babelHelpers.toConsumableArray(attr);
      }
    }, {
      key: "resetAnswers",
      value:
      /**
       * Reset user answers and shuffle the board again.
       */
      function resetAnswers(e) {
        window.dispatchEvent(new CustomEvent("simple-toast-hide", {
          bubbles: true,
          composed: true,
          cancelable: false,
          detail: false
        }));
        this.displayedAnswers = [];
        this.answers.forEach(function (el) {
          el.userGuess = false;
        });
        var answers = JSON.parse(JSON.stringify(this.answers));
        this.answers = babelHelpers.toConsumableArray(answers);
      }

      /**
       * Return if the current answers are correct
       */
    }, {
      key: "checkAnswers",
      value: function checkAnswers() {
        var gotRight = true;
        // see that they got them all right
        for (var i in this.displayedAnswers) {
          if (gotRight != false && this.displayedAnswers[i].correct && this.displayedAnswers[i].userGuess) {
            gotRight = true;
          } else if (this.displayedAnswers[i].correct && !this.displayedAnswers[i].userGuess) {
            gotRight = false;
          } else if (!this.displayedAnswers[i].correct && this.displayedAnswers[i].userGuess) {
            gotRight = false;
          }
        }
        return gotRight;
      }
      /**
       * Verify the answers of the user based on their saying
       * that they want to see how they did.
       */
    }, {
      key: "_verifyAnswers",
      value: function _verifyAnswers(e) {
        var _this5 = this;
        window.dispatchEvent(new CustomEvent("simple-toast-hide", {
          bubbles: true,
          composed: true,
          cancelable: false,
          detail: false
        }));
        var si = document.createElement("simple-icon-lite");
        var extras = {};
        var toastShowEventName = "simple-toast-show";
        // support for haxcms toast
        if (window.HAXCMSToast) {
          toastShowEventName = "haxcms-toast-show";
          si.style.setProperty("--simple-icon-height", "40px");
          si.style.setProperty("--simple-icon-width", "40px");
          si.style.height = "150px";
          si.style.marginLeft = "8px";
        }
        var gotRight = this.checkAnswers();
        // see if they got this correct based on their answers
        if (gotRight) {
          this.__toastColor = "green";
          this.__toastIcon = this.correctIcon;
          this.__toastText = this.correctText;
          // make it fun... and performant!
          new Promise(function (res, rej) {
            return _require.default(["./lib/confetti-container.js"], res, rej);
          }).then(function (module) {
            setTimeout(function () {
              _this5.shadowRoot.querySelector("#confetti").setAttribute("popped", "");
            }, 0);
          });
          extras.hat = "party";
        } else {
          this.__toastColor = "red";
          this.__toastIcon = this.incorrectIcon;
          this.__toastText = this.incorrectText;
          extras.fire = true;
        }
        si.icon = this.__toastIcon;
        si.style.marginLeft = "16px";
        si.accentColor = this.__toastColor;
        si.dark = true;
        // gets it all the way to the top immediately
        window.dispatchEvent(new CustomEvent(toastShowEventName, {
          bubbles: true,
          composed: true,
          cancelable: true,
          detail: _objectSpread({
            text: this.__toastText,
            accentColor: this.__toastColor,
            duration: 3000,
            slot: si
          }, extras)
        }));
        // start of data passing, this is a prototype atm
        var eventData = {
          activityDisplay: "answered",
          objectName: this.quizName,
          resultSuccess: gotRight
        };
        this.dispatchEvent(new CustomEvent("user-engagement", {
          bubbles: true,
          composed: true,
          cancelable: false,
          detail: eventData
        }));
      }

      /**
       * Figure out the order of the answers which will be displayed
       */
    }, {
      key: "_computeDisplayedAnswers",
      value: function _computeDisplayedAnswers(answers, randomize) {
        // if we are editing via HAX, don't randomize the answers
        // as we are actively editing the content and this is amazingly jarring
        if (babelHelpers.typeof(answers) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && answers != null && answers.length > 0 && randomize && !this._haxstate) {
          var random = answers;
          var currentIndex = random.length,
            temporaryValue,
            randomIndex;
          // While there remain elements to shuffle...
          while (0 !== currentIndex) {
            // Pick a remaining element...
            randomIndex = Math.floor(Math.random() * currentIndex);
            currentIndex -= 1;
            // And swap it with the current element.
            temporaryValue = random[currentIndex];
            random[currentIndex] = random[randomIndex];
            random[randomIndex] = temporaryValue;
          }
          // @todo apply a random sort to the answers array
          return random;
        } else {
          return answers;
        }
      }
      /**
       * haxProperties integration via file reference
       */
    }, {
      key: "haxHooks",
      value:
      /**
       * Implements haxHooks to tie into life-cycle if hax exists.
       */
      function haxHooks() {
        return {
          editModeChanged: "haxeditModeChanged",
          activeElementChanged: "haxactiveElementChanged",
          preProcessNodeToContent: "haxpreProcessNodeToContent",
          preProcessInsertContent: "haxpreProcessInsertContent",
          inlineContextMenu: "haxinlineContextMenu"
        };
      }
    }, {
      key: "haxactiveElementChanged",
      value: function haxactiveElementChanged(element, value) {
        if (value) {
          this._haxstate = value;
        }
      }
    }, {
      key: "haxeditModeChanged",
      value: function haxeditModeChanged(value) {
        this._haxstate = value;
      }
      /**
       * add buttons when it is in context
       */
    }, {
      key: "haxinlineContextMenu",
      value: function haxinlineContextMenu(ceMenu) {
        ceMenu.ceButtons = [{
          icon: "icons:add",
          callback: "haxClickInlineAdd",
          label: "Add answer"
        }, {
          icon: "icons:remove",
          callback: "haxClickInlineRemove",
          label: "Remove answer"
        }];
      }
    }, {
      key: "haxClickInlineAdd",
      value: function haxClickInlineAdd(e) {
        this.resetAnswers();
        var d = this.answers;
        d.push({
          label: "New answer",
          correct: false
        });
        this.answers = babelHelpers.toConsumableArray(d);
        return true;
      }
    }, {
      key: "haxClickInlineRemove",
      value: function haxClickInlineRemove(e) {
        if (this.answers.length > 0) {
          this.resetAnswers();
          var d = this.answers;
          d.pop();
          this.answers = babelHelpers.toConsumableArray(d);
          return true;
        }
      }
      /**
       * HAX preprocess Node to Content hook
       */
    }, {
      key: "haxpreProcessNodeToContent",
      value: function () {
        var _haxpreProcessNodeToContent = babelHelpers.asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(node) {
          var i, answer;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                // ensure we dont accidently have the answer displayed!
                // this also rips the data into the lightDom for saving
                // so that we can unset the array data on the object at save time
                // this helps improve SEO / compatibility with CMS solutions
                if (node.answers) {
                  // ensure this is null before generating new answers
                  // otherwise page to page saves we could lose statefulness
                  this.innerHTML = "";
                  for (i in node.answers) {
                    answer = document.createElement("input");
                    answer.setAttribute("type", "checkbox");
                    answer.value = node.answers[i].label;
                    if (node.answers[i].correct) {
                      answer.setAttribute("correct", "correct");
                    }
                    node.appendChild(answer);
                  }
                }
                return _context.abrupt("return", node);
              case 2:
              case "end":
                return _context.stop();
            }
          }, _callee, this);
        }));
        function haxpreProcessNodeToContent(_x) {
          return _haxpreProcessNodeToContent.apply(this, arguments);
        }
        return haxpreProcessNodeToContent;
      }()
      /**
       * HAX preprocess insert content hook
       */
    }, {
      key: "haxpreProcessInsertContent",
      value: function haxpreProcessInsertContent(detail, activeNode) {
        // ensure we dont accidently have the answer displayed!
        if (detail.properties.answers) {
          detail.properties.answers = detail.properties.answers.map(function (val) {
            if (val.userGuess) {
              delete val.userGuess;
            }
            return val;
          });
        }
        return detail;
      }
    }, {
      key: "firstUpdated",
      value: function firstUpdated(changedProperties) {
        if (babelHelpers.get(babelHelpers.getPrototypeOf(MultipleChoice.prototype), "firstUpdated", this)) {
          babelHelpers.get(babelHelpers.getPrototypeOf(MultipleChoice.prototype), "firstUpdated", this).call(this, changedProperties);
        }
        this.setAttribute("typeof", "oer:Assessment");
        // check lightdom on setup for answers to be read in
        // this only happens on initial paint
        if (this.children.length > 0) {
          var inputs = Array.from(this.querySelectorAll("input"));
          var answers = [];
          for (var i in inputs) {
            var answer = {
              label: inputs[i].value,
              correct: inputs[i].getAttribute("correct") == null ? false : true
            };
            answers.push(answer);
          }
          this.answers = answers;
          // wipe lightdom after reading it in for data. This makes it harder for someone
          // to just inspect the document and get at the underlying data
          this.innerHTML = "";
        }
      }
    }], [{
      key: "styles",
      get:
      /**
       * LitElement constructable styles enhancement
       */
      function get() {
        return [].concat(babelHelpers.toConsumableArray(babelHelpers.get(babelHelpers.getPrototypeOf(MultipleChoice), "styles", this)), [(0, _index.css)(_templateObject7_33233b30e8f211edb01b473406559cea || (_templateObject7_33233b30e8f211edb01b473406559cea = babelHelpers.taggedTemplateLiteral(["\n        :host {\n          display: block;\n          min-width: 160px;\n          padding: 16px;\n          margin-bottom: 16px;\n          border: 1px solid var(--simple-colors-default-theme-grey-8);\n          border-radius: 3px;\n          color: var(--simple-colors-default-theme-grey-12);\n          --simple-toolbar-button-border-color: var(\n            --simple-colors-default-theme-grey-4\n          );\n          --simple-fields-field-color: var(\n            --simple-colors-default-theme-grey-12\n          );\n          --simple-fields-field-ink-color: var(\n            --simple-colors-default-theme-grey-12\n          );\n          --simple-fields-field-checked-color: var(\n            --simple-colors-default-theme-accent-8\n          );\n          --simple-fields-field-checked-ink-color: var(\n            --simple-colors-default-theme-accent-8\n          );\n          --simple-fields-field-checkmark-color: var(\n            --simple-colors-default-theme-grey-1\n          );\n          --simple-fields-field-label-color: var(\n            --simple-colors-default-theme-grey-12\n          );\n          --simple-fields-field-error-color: var(\n            --simple-colors-default-theme-red-8\n          );\n          --simple-fields-border-bottom-size: 0px;\n          --simple-fields-border-bottom-focus-size: 0px;\n        }\n\n        :host button {\n          background-color: var(--simple-colors-default-theme-grey-1);\n          color: var(--simple-colors-default-theme-grey-12);\n        }\n        :host button:hover,\n        :host button:focus,\n        :host button:active {\n          cursor: pointer;\n          background-color: var(--simple-colors-default-theme-grey-2);\n          color: var(--simple-colors-default-theme-grey-12);\n        }\n        ul {\n          list-style: none;\n          padding: 0;\n          margin: 0;\n        }\n        ul li {\n          padding: 0;\n        }\n        simple-icon {\n          display: inline-flex;\n        }\n        h3 {\n          margin-top: 0;\n        }\n        #buttons {\n          display: flex;\n          align-items: center;\n          justify-content: flex-end;\n        }\n        #check {\n          margin-right: 8px;\n        }\n        simple-fields-field {\n          padding: 8px;\n          margin: 2px;\n        }\n        simple-fields-field::part(option-inner) {\n          position: absolute;\n          right: 0px;\n          bottom: 50%;\n          top: 50%;\n          padding: 0px;\n          margin: 0px;\n        }\n        simple-icon {\n          display: inline-flex;\n        }\n      "])))]);
      }
    }, {
      key: "tag",
      get: function get() {
        return "multiple-choice";
      }
    }, {
      key: "properties",
      get: function get() {
        return _objectSpread(_objectSpread({}, babelHelpers.get(babelHelpers.getPrototypeOf(MultipleChoice), "properties", this)), {}, {
          /**
           * Support disabling interaction with the entire board
           */
          disabled: {
            type: Boolean
          },
          /**
           * Simple option, otherwise allow multiple via checkbox
           */
          singleOption: {
            type: Boolean,
            attribute: "single-option"
          },
          /**
           * Text of the label to check your answer
           */
          checkLabel: {
            type: String,
            attribute: "check-label"
          },
          /**
           * Text of the reset button
           */
          resetLabel: {
            type: String,
            attribute: "reset-label"
          },
          /**
           * Related Resource ID
           */
          relatedResource: {
            type: String,
            attribute: "related-resource"
          },
          /**
           * Question to ask
           */
          question: {
            type: String
          },
          /**
           * Array of possible answers
           */
          answers: {
            type: Array
          },
          /**
           * Displayed Answer set.
           */
          displayedAnswers: {
            type: Array
          },
          /**
           * Correct answer text to display
           */
          correctText: {
            type: String,
            attribute: "correct-text"
          },
          /**
           * Incorrect answer text to display
           */
          incorrectText: {
            type: String,
            attribute: "incorrect-text"
          },
          /**
           * Correct answer text to display
           */
          correctIcon: {
            type: String,
            attribute: "correct-icon"
          },
          /**
           * Incorrect answer text to display
           */
          incorrectIcon: {
            type: String,
            attribute: "incorrect-icon"
          },
          /**
           * Name of the quiz - hardcoded for now from HTML
           */
          quizName: {
            type: String,
            attribute: "quiz-name"
          },
          /**
           * Randomize the display of the answers
           */
          randomize: {
            type: Boolean,
            reflect: true
          },
          /**
           * flag to hide buttons
           */
          hideButtons: {
            type: Boolean,
            attribute: "hide-buttons"
          }
        });
      }
    }, {
      key: "haxProperties",
      get: function get() {
        return new URL("./lib/".concat(this.tag, ".haxProperties.json"), meta.url).href;
      }
    }]);
    return MultipleChoice;
  }((0, _schemaBehaviors.SchemaBehaviors)((0, _simpleColors.SimpleColorsSuper)(_index.LitElement)));
  _exports.MultipleChoice = MultipleChoice;
  window.customElements.define(MultipleChoice.tag, MultipleChoice);
});