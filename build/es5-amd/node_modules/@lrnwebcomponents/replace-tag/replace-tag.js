define(["exports", "./lib/loading-styles.js", "../wc-autoload/wc-autoload.js"], function (_exports, _loadingStyles, _wcAutoload) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.ReplaceTag = void 0;

  function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * `replace-tag`
   * `Loading helpers and css`
   * @demo demo/index.html
   * @element replace-tag
   */
  var ReplaceTagSuper = function ReplaceTagSuper(SuperClass) {
    return /*#__PURE__*/function (_SuperClass) {
      babelHelpers.inherits(_class, _SuperClass);

      var _super = _createSuper(_class);

      function _class() {
        babelHelpers.classCallCheck(this, _class);
        return _super.call(this);
      }
      /**
       * HTMLElement specification
       */


      babelHelpers.createClass(_class, [{
        key: "disconnectedCallback",
        value: function disconnectedCallback() {
          // if we have an intersection observer, disconnect it
          if (this.intersectionObserver) {
            this.intersectionObserver.disconnect();
          }

          if (babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype), "disconnectedCallback", this)) {
            babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype), "disconnectedCallback", this).call(this);
          }
        } // define the scafold for how this will self-replace when updated

      }, {
        key: "connectedCallback",
        value: function connectedCallback() {
          if (babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype), "connectedCallback", this)) {
            babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype), "connectedCallback", this).call(this);
          }

          this.evaluateReplaceMethod();
        }
      }, {
        key: "performanceBasedReplacement",
        value: function performanceBasedReplacement() {
          this.setAttribute("laser-loader", "laser-loader");
          this.loadingStatement = "Loading...";
          this.render();
          this.runReplacement();
        }
        /**
         * evaluate based on user device and other settings HOW to handle the replacement
         */

      }, {
        key: "evaluateReplaceMethod",
        value: function evaluateReplaceMethod() {
          // ensure that ANY replace-tag gets this applied
          window.WCRegistryLoaderCSS();
          var crappy = false;

          if (this.getAttribute("with-method") != "view") {
            if (navigator) {
              // if less than a gig we know its bad
              if (navigator.deviceMemory && navigator.deviceMemory < 1) {
                crappy = true;
              } // even phones have multi-core processors so another sign


              if (navigator.hardwareConcurrency && navigator.hardwareConcurrency < 2) {
                crappy = true;
              } // some platforms support getting the battery status


              if (navigator.getBattery) {
                navigator.getBattery().then(function (battery) {
                  // if we are not charging AND we have under 25% be kind
                  if (!battery.charging && battery.level < 0.25) {
                    crappy = true;
                  }
                });
              } // some things report the "type" of internet connection speed
              // for terrible connections lets save frustration


              if (navigator.connection && navigator.connection.effectiveType && ["slow-2g", "2g", "3g"].includes(navigator.connection.effectiveType)) {
                crappy = true;
              } // see if they said "hey, save me data"


              if (navigator.connection && navigator.connection.saveData) {
                crappy = true;
              }
            } // look at browser performance
            // if below a threashold display message to replace on tap


            if (crappy) {
              this.loadingStatement = "Click / Tap to load";
              this.addEventListener("click", this.performanceBasedReplacement);
            }
          } // if we don't have a poor device or another setting is used, then we are
          // expected to use lazy loading as it comes into the viewport like the rest


          if (!crappy) {
            this.setAttribute("laser-loader", "laser-loader");
            this.loadingStatement = "Loading...";
            this.intersectionObserver = new IntersectionObserver(this.handleIntersectionCallback.bind(this), {
              root: document.rootElement,
              rootMargin: "0px",
              threshold: [0.0, 0.25, 0.5, 0.75, 1.0],
              delay: 250
            });
            this.intersectionObserver.observe(this);
          }

          this.render();
        }
        /**
         * Very basic IntersectionObserver callback which will replace on visible
         */

      }, {
        key: "handleIntersectionCallback",
        value: function handleIntersectionCallback(entries) {
          var _iterator = _createForOfIteratorHelper(entries),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var entry = _step.value;
              var ratio = Number(entry.intersectionRatio).toFixed(2); // ensure ratio is higher than our limit before trigger visibility

              if (ratio >= 0.25) {
                this.intersectionObserver.disconnect();
                this.intersectionObserver = null;
                this.runReplacement();
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
        /**
         * replacement callback; avoiding use of replace bc of built in JS expectation for this method
         */

      }, {
        key: "runReplacement",
        value: function runReplacement() {
          var _this = this;

          // ensure we have something to replace this with
          if (this.getAttribute("with")) {
            setTimeout(function () {
              // kicks off the definition to load from the registry if its in there
              window.WCAutoload.requestAvailability().registry.loadDefinition(_this.getAttribute("with"));
              customElements.whenDefined(_this.getAttribute("with")).then(function (response) {
                // just the props off of this for complex state
                var props = {};

                for (var i = 0, atts = _this.attributes, n = atts.length; i < n; i++) {
                  props[atts[i].nodeName] = atts[i].nodeValue;
                }

                var replacement = document.createElement(props.with);
                replacement.setAttribute("popup-loader", "popup-loader"); // set the value in the new object

                for (var i in props) {
                  if (props[i] != null) {
                    replacement.setAttribute(i, props[i]);
                  }
                }

                replacement.removeAttribute("laser-loader");
                replacement.innerHTML = _this.innerHTML;

                _this.replaceWith(replacement);

                setTimeout(function () {
                  replacement.removeAttribute("popup-loader");
                  replacement.removeAttribute("laser-loader");
                  replacement.style.setProperty("--laserEdgeAni-width", null);
                  replacement.style.setProperty("--laserEdgeAni-innerWidth", null);
                  replacement.style.setProperty("--laserEdgeAni-height", null);
                  replacement.style.setProperty("--laserEdgeAni-innerHeight", null); // we resolved 1 definition so now we know it's safe to do all of them

                  document.querySelectorAll('replace-tag[with="' + props.with + '"]').forEach(function (el) {
                    el.runReplacement();
                  });
                }, 250);
              });
            }, 250);
          } else {
            console.warn("replace-tag requires use of with attribute for what to upgrade to");
          }
        }
      }]);
      return _class;
    }(SuperClass);
  };

  var ReplaceTag = /*#__PURE__*/function (_ReplaceTagSuper) {
    babelHelpers.inherits(ReplaceTag, _ReplaceTagSuper);

    var _super2 = _createSuper(ReplaceTag);

    function ReplaceTag() {
      var _this2;

      babelHelpers.classCallCheck(this, ReplaceTag);
      _this2 = _super2.call(this);
      _this2.template = document.createElement("template");

      _this2.attachShadow({
        mode: "open"
      });

      return _this2;
    }
    /**
     * Convention we use
     */


    babelHelpers.createClass(ReplaceTag, [{
      key: "render",
      value: function render() {
        this.shadowRoot.innerHTML = null;
        this.template.innerHTML = this.html;

        if (window.ShadyCSS) {
          window.ShadyCSS.prepareTemplate(this.template, this.tag);
        }

        this.shadowRoot.appendChild(this.template.content.cloneNode(true));
      }
    }, {
      key: "html",
      get: function get() {
        return "\n    <style>\n    :host {\n      display: block;\n      background-color: #DDDDDD;\n      color: black;\n      font-size: 16px;\n      margin:16px;\n      padding: 16px;\n      opacity: .8;\n      transition: .3s linear all;\n    }\n    :host(:not([with-method=\"view\"]):hover) {\n      opacity: 1 !important;\n      outline: 1px solid black;\n      cursor: pointer;\n    }\n    :host([hidden]) {\n      display: none;\n    }\n    </style>\n<div>".concat(this.loadingStatement, "</div>");
      }
    }], [{
      key: "tag",
      get: function get() {
        return "replace-tag";
      }
    }]);
    return ReplaceTag;
  }(ReplaceTagSuper(HTMLElement));

  _exports.ReplaceTag = ReplaceTag;
  customElements.define(ReplaceTag.tag, ReplaceTag);
});